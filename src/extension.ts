import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { CMakeEditorProvider } from './providers/CMakeEditorProvider';
import { YAMLSerializer } from './core/generator/YAMLSerializer';
import { CMakeGenerator } from './core/generator/CMakeGenerator';
import { Project } from './core/model/Project';
import { findCommonParentDirectory } from './utils/pathUtils';
import { writeCMakeListsWithMarkers, hasAutoGeneratedSections } from './utils/cmakeFileManager';

export function activate(context: vscode.ExtensionContext) {
  console.log('CMakeMakers extension is now active');

  // Register custom editor provider
  const editorProvider = new CMakeEditorProvider(context);
  context.subscriptions.push(
    vscode.window.registerCustomEditorProvider(
      'cmakemakers.configEditor',
      editorProvider,
      {
        webviewOptions: {
          retainContextWhenHidden: true
        },
        supportsMultipleEditorsPerDocument: false
      }
    )
  );

  // Register command: Open Config Editor
  context.subscriptions.push(
    vscode.commands.registerCommand('cmakemakers.openEditor', async () => {
      const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
      if (!workspaceFolder) {
        vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
        return;
      }

      const configPath = path.join(workspaceFolder.uri.fsPath, 'cmake', 'cmaker_config.yaml');

      // Check if config exists
      if (!fs.existsSync(configPath)) {
        const create = await vscode.window.showInformationMessage(
          'é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ˜¯å¦åˆ›å»ºæ–°é…ç½®ï¼Ÿ',
          'åˆ›å»º',
          'å–æ¶ˆ'
        );

        if (create === 'åˆ›å»º') {
          await createDefaultConfig(configPath);
        } else {
          return;
        }
      }

      // Open the config file with custom editor
      const document = await vscode.workspace.openTextDocument(configPath);
      await vscode.window.showTextDocument(document);
    })
  );

  // Register command: Generate CMakeLists.txt
  context.subscriptions.push(
    vscode.commands.registerCommand('cmakemakers.generate', async (uri?: vscode.Uri) => {
      try {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
          vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
          return;
        }

        // Determine config file path
        let configPath: string;
        if (uri && uri.fsPath.endsWith('cmaker_config.yaml')) {
          configPath = uri.fsPath;
        } else {
          configPath = path.join(workspaceFolder.uri.fsPath, 'cmake', 'cmaker_config.yaml');
        }

        if (!fs.existsSync(configPath)) {
          vscode.window.showErrorMessage('æ‰¾ä¸åˆ°é…ç½®æ–‡ä»¶: cmaker_config.yaml');
          return;
        }

        // Read and parse YAML
        const yamlContent = fs.readFileSync(configPath, 'utf-8');
        const serializer = new YAMLSerializer();
        const projectData = serializer.deserialize(yamlContent);

        // Generate CMakeLists.txt
        const generator = new CMakeGenerator();
        const cmakeContent = generator.generate(projectData);

        // Determine optimal location for CMakeLists.txt
        // Strategy: Find common parent directory of all source files
        const configDir = path.dirname(configPath);
        const projectRoot = path.dirname(configDir);

        // Find common parent directory of all source files
        const commonDir = findCommonParentDirectory(projectData, projectRoot);
        const cmakeListsPath = path.join(commonDir, 'CMakeLists.txt');

        // Check for conflicts with existing non-generated CMakeLists.txt
        if (fs.existsSync(cmakeListsPath)) {
          const hasAutoGenerated = hasAutoGeneratedSections(cmakeListsPath);

          if (!hasAutoGenerated) {
            // File exists and has no auto-generated sections
            // This means it's likely manually written - prompt user
            const relativePath = path.relative(workspaceFolder.uri.fsPath, cmakeListsPath);
            const choice = await vscode.window.showWarningMessage(
              `${relativePath} å·²å­˜åœ¨ä¸”åŒ…å«æ‰‹åŠ¨ç¼–å†™çš„å†…å®¹ã€‚\n` +
              `CMakeMakers å°†åœ¨æ–‡ä»¶æœ«å°¾è¿½åŠ è‡ªåŠ¨ç”Ÿæˆçš„éƒ¨åˆ†ï¼Œå¹¶ç”¨ç‰¹æ®Šæ³¨é‡Šæ ‡è®°ã€‚\n` +
              `ä½ çš„æ‰‹åŠ¨å†…å®¹ä¸ä¼šè¢«è¦†ç›–ã€‚`,
              { modal: true },
              'ç»§ç»­è¿½åŠ ',
              'å–æ¶ˆ'
            );

            if (choice !== 'ç»§ç»­è¿½åŠ ') {
              vscode.window.showInformationMessage('å·²å–æ¶ˆç”Ÿæˆ');
              return;
            }
          }
        }

        // Write or update CMakeLists.txt with markers
        const relativeConfigPath = path.relative(projectRoot, configPath);
        writeCMakeListsWithMarkers({
          cmakeListsPath,
          generatedContent: cmakeContent,
          configPath: relativeConfigPath
        });

        const relativePath = path.relative(workspaceFolder.uri.fsPath, cmakeListsPath);
        vscode.window.showInformationMessage(
          `âœ… CMakeLists.txt å·²ç”Ÿæˆ: ${relativePath}\n` +
          `ðŸ’¡ è‡ªåŠ¨ç”Ÿæˆçš„éƒ¨åˆ†å·²ç”¨æ³¨é‡Šæ ‡è®°ï¼Œä½ å¯ä»¥åœ¨æ–‡ä»¶ä¸­æ·»åŠ è‡ªå®šä¹‰å†…å®¹`
        );

        // Open the generated file
        const doc = await vscode.workspace.openTextDocument(cmakeListsPath);
        await vscode.window.showTextDocument(doc, { preview: false });

      } catch (error) {
        vscode.window.showErrorMessage(`ç”Ÿæˆå¤±è´¥: ${error}`);
        console.error('Generate error:', error);
      }
    })
  );

  // Register command: New Project from Template
  context.subscriptions.push(
    vscode.commands.registerCommand('cmakemakers.newProject', async () => {
      const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
      if (!workspaceFolder) {
        vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
        return;
      }

      // Show template picker
      const templates = [
        { label: 'æŽ§åˆ¶å°åº”ç”¨', description: 'Console Application', value: 'console-app' },
        { label: 'é™æ€åº“', description: 'Static Library', value: 'static-lib' },
        { label: 'å…±äº«åº“', description: 'Shared Library', value: 'shared-lib' }
      ];

      const selected = await vscode.window.showQuickPick(templates, {
        placeHolder: 'é€‰æ‹©é¡¹ç›®æ¨¡æ¿'
      });

      if (!selected) {
        return;
      }

      // Get project name
      const projectName = await vscode.window.showInputBox({
        prompt: 'è¾“å…¥é¡¹ç›®åç§°',
        value: 'MyProject',
        validateInput: (value) => {
          if (!value || value.trim().length === 0) {
            return 'é¡¹ç›®åç§°ä¸èƒ½ä¸ºç©º';
          }
          if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value)) {
            return 'é¡¹ç›®åç§°åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œä¸”ä¸èƒ½ä»¥æ•°å­—å¼€å¤´';
          }
          return null;
        }
      });

      if (!projectName) {
        return;
      }

      try {
        // Load template
        const templatePath = path.join(context.extensionPath, 'templates', `${selected.value}.yaml`);

        if (!fs.existsSync(templatePath)) {
          vscode.window.showErrorMessage(`æ¨¡æ¿æ–‡ä»¶ä¸å­˜åœ¨: ${selected.value}.yaml`);
          return;
        }

        const templateContent = fs.readFileSync(templatePath, 'utf-8');
        const serializer = new YAMLSerializer();
        const projectData = serializer.deserialize(templateContent);

        // Update project name
        projectData.project.name = projectName;

        // Serialize back to YAML
        const yamlContent = serializer.serialize(projectData);

        // Create cmake directory if not exists
        const cmakeDir = path.join(workspaceFolder.uri.fsPath, 'cmake');
        if (!fs.existsSync(cmakeDir)) {
          fs.mkdirSync(cmakeDir, { recursive: true });
        }

        // Write config file
        const configPath = path.join(cmakeDir, 'cmaker_config.yaml');
        fs.writeFileSync(configPath, yamlContent, 'utf-8');

        vscode.window.showInformationMessage(`âœ… é¡¹ç›®é…ç½®å·²åˆ›å»º: ${projectName}`);

        // Open the config file
        const doc = await vscode.workspace.openTextDocument(configPath);
        await vscode.window.showTextDocument(doc);

      } catch (error) {
        vscode.window.showErrorMessage(`åˆ›å»ºé¡¹ç›®å¤±è´¥: ${error}`);
        console.error('New project error:', error);
      }
    })
  );

  // Setup file watcher for config changes
  const configWatcher = vscode.workspace.createFileSystemWatcher(
    '**/cmake/cmaker_config.yaml'
  );

  configWatcher.onDidChange(async (uri) => {
    console.log('Config file changed:', uri.fsPath);
    // Auto-generate CMakeLists.txt if enabled
    const config = vscode.workspace.getConfiguration('cmakemakers');
    if (config.get('autoGenerate', false)) {
      await vscode.commands.executeCommand('cmakemakers.generate', uri);
    }
  });

  context.subscriptions.push(configWatcher);
}

export function deactivate() {
  console.log('CMakeMakers extension is now deactivated');
}

// Helper function to create default config
async function createDefaultConfig(configPath: string): Promise<void> {
  const project = new Project();
  const serializer = new YAMLSerializer();
  const yamlContent = serializer.serialize(project.getData());

  // Ensure directory exists
  const dir = path.dirname(configPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(configPath, yamlContent, 'utf-8');
}
