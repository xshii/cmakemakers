import { CMakeProject, Target, Scope, SourceEntry } from '../model/types';

export class CMakeGenerator {
  /**
   * Generate CMakeLists.txt content from project
   */
  generate(project: CMakeProject): string {
    const lines: string[] = [];

    // Header comment
    lines.push('# Generated by CMakeMakers');
    lines.push(`# Last modified: ${new Date().toISOString()}`);
    lines.push('');

    // cmake_minimum_required
    lines.push(`cmake_minimum_required(VERSION ${project.project.cmake_minimum_required})`);
    lines.push('');

    // project()
    const langs = project.project.languages.join(' ');
    if (project.project.version) {
      lines.push(`project(${project.project.name} VERSION ${project.project.version} LANGUAGES ${langs})`);
    } else {
      lines.push(`project(${project.project.name} LANGUAGES ${langs})`);
    }
    lines.push('');

    // Global configuration
    if (project.global) {
      lines.push('# Global configuration');

      if (project.global.cxx_standard) {
        lines.push(`set(CMAKE_CXX_STANDARD ${project.global.cxx_standard})`);
      }
      if (project.global.cxx_standard_required) {
        lines.push(`set(CMAKE_CXX_STANDARD_REQUIRED ON)`);
      }
      if (project.global.cxx_extensions === false) {
        lines.push(`set(CMAKE_CXX_EXTENSIONS OFF)`);
      }
      if (project.global.default_build_type) {
        lines.push(`set(CMAKE_BUILD_TYPE ${project.global.default_build_type} CACHE STRING "Build type")`);
      }

      // Variables
      if (project.global.variables && project.global.variables.length > 0) {
        for (const v of project.global.variables) {
          if (v.cache) {
            lines.push(`set(${v.name} "${v.value}" CACHE ${v.type || 'STRING'} "${v.description || ''}")`);
          } else {
            lines.push(`set(${v.name} "${v.value}")`);
          }
        }
      }

      // Options
      if (project.global.options && project.global.options.length > 0) {
        for (const opt of project.global.options) {
          lines.push(`option(${opt.name} "${opt.description || ''}" ${opt.value ? 'ON' : 'OFF'})`);
        }
      }

      lines.push('');
    }

    // Toolchain
    if (project.toolchain && project.toolchain.file) {
      lines.push(`# Toolchain`);
      lines.push(`set(CMAKE_TOOLCHAIN_FILE "${project.toolchain.file}")`);
      lines.push('');
    }

    // find_package dependencies
    if (project.dependencies && project.dependencies.length > 0) {
      lines.push('# Dependencies');
      for (const dep of project.dependencies) {
        if (dep.type === 'find_package' && dep.find_package) {
          const fp = dep.find_package;
          let cmd = `find_package(${fp.package}`;
          if (fp.version) {
            cmd += ` ${fp.version}`;
          }
          if (fp.required) {
            cmd += ` REQUIRED`;
          }
          if (fp.components && fp.components.length > 0) {
            cmd += ` COMPONENTS ${fp.components.join(' ')}`;
          }
          cmd += ')';
          lines.push(cmd);
        }
      }
      lines.push('');
    }

    // Targets
    for (const target of project.targets) {
      lines.push(...this.generateTarget(target));
      lines.push('');
    }

    return lines.join('\n');
  }

  private generateTarget(target: Target): string[] {
    const lines: string[] = [];

    lines.push(`# Target: ${target.name}`);

    // add_executable or add_library
    const targetType = this.getTargetTypeCommand(target.type);
    lines.push(`${targetType}(${target.name}`);

    // Sources
    if (target.sources && target.sources.length > 0) {
      for (const source of target.sources) {
        if (source.type === 'file' && source.path) {
          lines.push(`    ${source.path}`);
        } else if (source.type === 'glob' && source.pattern) {
          // Will be generated separately
        }
      }
    }

    lines.push(')');
    lines.push('');

    // Handle glob sources
    for (const source of target.sources) {
      if (source.type === 'glob' && source.pattern) {
        lines.push(...this.generateGlobSources(target.name, source));
        lines.push('');
      }
    }

    // target_include_directories
    if (target.include_directories && target.include_directories.length > 0) {
      lines.push(`target_include_directories(${target.name}`);
      this.groupByScope(target.include_directories).forEach(([scope, items]) => {
        lines.push(`    ${scope}`);
        items.forEach(item => lines.push(`        ${item.path}`));
      });
      lines.push(')');
      lines.push('');
    }

    // target_link_libraries
    if (target.link_libraries && target.link_libraries.length > 0) {
      // Add find_package for package libraries
      const packages = target.link_libraries.filter(lib => lib.type === 'package' && lib.find_package);
      for (const lib of packages) {
        if (lib.find_package) {
          lines.push(`find_package(${lib.find_package.package} ${lib.find_package.version || ''} ${lib.find_package.required ? 'REQUIRED' : ''})`);
        }
      }
      if (packages.length > 0) {
        lines.push('');
      }

      lines.push(`target_link_libraries(${target.name}`);
      this.groupByScope(target.link_libraries).forEach(([scope, items]) => {
        lines.push(`    ${scope}`);
        items.forEach(item => lines.push(`        ${item.name}`));
      });
      lines.push(')');
      lines.push('');
    }

    // target_compile_definitions
    if (target.compile_definitions && target.compile_definitions.length > 0) {
      lines.push(`target_compile_definitions(${target.name}`);
      this.groupByScope(target.compile_definitions).forEach(([scope, items]) => {
        lines.push(`    ${scope}`);
        items.forEach(item => {
          const def = item.value ? `${item.name}=${item.value}` : item.name;
          lines.push(`        ${def}`);
        });
      });
      lines.push(')');
      lines.push('');
    }

    // target_compile_options
    if (target.compile_options && target.compile_options.length > 0) {
      lines.push(`target_compile_options(${target.name}`);
      this.groupByScope(target.compile_options).forEach(([scope, items]) => {
        lines.push(`    ${scope}`);
        items.forEach(item => lines.push(`        ${item.option}`));
      });
      lines.push(')');
      lines.push('');
    }

    // Properties
    if (target.properties && target.properties.length > 0) {
      for (const prop of target.properties) {
        lines.push(`set_target_properties(${target.name} PROPERTIES ${prop.name} ${prop.value})`);
      }
      lines.push('');
    }

    return lines;
  }

  private generateGlobSources(targetName: string, source: SourceEntry): string[] {
    const lines: string[] = [];

    const globType = source.recursive ? 'GLOB_RECURSE' : 'GLOB';
    const varName = `${targetName.toUpperCase()}_SOURCES`;

    let cmd = `file(${globType} ${varName}`;
    if (source.configure_depends) {
      cmd += ' CONFIGURE_DEPENDS';
    }
    lines.push(cmd);
    lines.push(`    "${source.pattern}"`);
    lines.push(')');

    // Exclude patterns
    if (source.exclude && source.exclude.length > 0) {
      for (const pattern of source.exclude) {
        lines.push(`list(FILTER ${varName} EXCLUDE REGEX "${pattern}")`);
      }
    }

    lines.push(`target_sources(${targetName} PRIVATE \${${varName}})`);

    return lines;
  }

  private getTargetTypeCommand(type: string): string {
    switch (type) {
      case 'executable':
        return 'add_executable';
      case 'static_library':
        return 'add_library';
      case 'shared_library':
        return 'add_library';
      case 'interface_library':
        return 'add_library';
      case 'object_library':
        return 'add_library';
      default:
        return 'add_library';
    }
  }

  private groupByScope<T extends { scope: Scope }>(items: T[]): Array<[Scope, T[]]> {
    const grouped = new Map<Scope, T[]>();

    for (const item of items) {
      if (!grouped.has(item.scope)) {
        grouped.set(item.scope, []);
      }
      grouped.get(item.scope)!.push(item);
    }

    // Return in order: PUBLIC, PRIVATE, INTERFACE
    const result: Array<[Scope, T[]]> = [];
    if (grouped.has('PUBLIC')) {
      result.push(['PUBLIC', grouped.get('PUBLIC')!]);
    }
    if (grouped.has('PRIVATE')) {
      result.push(['PRIVATE', grouped.get('PRIVATE')!]);
    }
    if (grouped.has('INTERFACE')) {
      result.push(['INTERFACE', grouped.get('INTERFACE')!]);
    }

    return result;
  }
}
