import * as assert from 'assert';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import {
  writeCMakeListsWithMarkers,
  hasAutoGeneratedSections,
  extractManualContent
} from '../../utils/cmakeFileManager';

suite('CMake File Manager Test Suite', () => {
  let tempDir: string;
  let testFilePath: string;

  setup(() => {
    // Create a temporary directory for each test
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'cmakemakers-test-'));
    testFilePath = path.join(tempDir, 'CMakeLists.txt');
  });

  teardown(() => {
    // Clean up temporary directory
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  suite('writeCMakeListsWithMarkers', () => {
    test('Create new file with generated content', () => {
      const generatedContent = 'project(MyProject)\nadd_executable(app main.cpp)';
      const configPath = 'cmake/config.yaml';

      writeCMakeListsWithMarkers({
        cmakeListsPath: testFilePath,
        generatedContent,
        configPath
      });

      assert.ok(fs.existsSync(testFilePath));

      const content = fs.readFileSync(testFilePath, 'utf-8');
      assert.ok(content.includes('# BEGIN: Generated by CMakeMakers'));
      assert.ok(content.includes('# END: Generated by CMakeMakers'));
      assert.ok(content.includes('project(MyProject)'));
      assert.ok(content.includes(configPath));
    });

    test('Preserve manual content when updating', () => {
      const manualContent = '# Manual configuration\nset(MY_VAR "value")\n';
      fs.writeFileSync(testFilePath, manualContent, 'utf-8');

      const generatedContent = 'project(MyProject)\nadd_executable(app main.cpp)';

      writeCMakeListsWithMarkers({
        cmakeListsPath: testFilePath,
        generatedContent,
        configPath: 'cmake/config.yaml'
      });

      const content = fs.readFileSync(testFilePath, 'utf-8');

      // Should have manual content
      assert.ok(content.includes('# Manual configuration'));
      assert.ok(content.includes('set(MY_VAR "value")'));

      // Should have generated content
      assert.ok(content.includes('project(MyProject)'));

      // Manual content should come before generated
      const manualIndex = content.indexOf('# Manual configuration');
      const generatedIndex = content.indexOf('# BEGIN: Generated by CMakeMakers');
      assert.ok(manualIndex < generatedIndex);
    });

    test('Replace old auto-generated section', () => {
      const initialContent = `# Manual setup
set(CMAKE_CXX_STANDARD 17)

# ============================================================================
# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION
# Configuration: cmake/old_config.yaml
# Generated at: 2025-01-01T00:00:00Z
# ============================================================================

project(OldProject)
add_executable(old_app old.cpp)

# ============================================================================
# END: Generated by CMakeMakers
# ============================================================================
`;

      fs.writeFileSync(testFilePath, initialContent, 'utf-8');

      const newGeneratedContent = 'project(NewProject)\nadd_executable(new_app new.cpp)';

      writeCMakeListsWithMarkers({
        cmakeListsPath: testFilePath,
        generatedContent: newGeneratedContent,
        configPath: 'cmake/new_config.yaml'
      });

      const content = fs.readFileSync(testFilePath, 'utf-8');

      // Manual content should be preserved
      assert.ok(content.includes('# Manual setup'));
      assert.ok(content.includes('set(CMAKE_CXX_STANDARD 17)'));

      // Old generated content should be removed
      assert.ok(!content.includes('OldProject'));
      assert.ok(!content.includes('old_app'));
      assert.ok(!content.includes('old_config.yaml'));

      // New generated content should be present
      assert.ok(content.includes('NewProject'));
      assert.ok(content.includes('new_app'));
      assert.ok(content.includes('new_config.yaml'));

      // Should have only one auto-generated section
      const beginCount = (content.match(/# BEGIN: Generated by CMakeMakers/g) || []).length;
      assert.strictEqual(beginCount, 1);
    });

    test('Handle multiple auto-generated sections (legacy)', () => {
      const contentWithMultipleSections = `# Manual
set(VAR1 "value")

# ============================================================================
# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION
# Configuration: config1.yaml
# ============================================================================

project(Project1)

# ============================================================================
# END: Generated by CMakeMakers
# ============================================================================

# More manual content
set(VAR2 "value2")

# ============================================================================
# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION
# Configuration: config2.yaml
# ============================================================================

project(Project2)

# ============================================================================
# END: Generated by CMakeMakers
# ============================================================================
`;

      fs.writeFileSync(testFilePath, contentWithMultipleSections, 'utf-8');

      const newContent = 'project(NewProject)';

      writeCMakeListsWithMarkers({
        cmakeListsPath: testFilePath,
        generatedContent: newContent,
        configPath: 'config_new.yaml'
      });

      const content = fs.readFileSync(testFilePath, 'utf-8');

      // Manual content preserved
      assert.ok(content.includes('set(VAR1 "value")'));
      assert.ok(content.includes('set(VAR2 "value2")'));

      // Old generated sections removed
      assert.ok(!content.includes('Project1'));
      assert.ok(!content.includes('Project2'));

      // Only one new generated section
      const beginCount = (content.match(/# BEGIN: Generated by CMakeMakers/g) || []).length;
      assert.strictEqual(beginCount, 1);
      assert.ok(content.includes('NewProject'));
    });

    test('Handle malformed markers (BEGIN without END)', () => {
      const malformedContent = `# Manual
set(VAR "value")

# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION
# Configuration: old.yaml

project(OldProject)
# Missing END marker
`;

      fs.writeFileSync(testFilePath, malformedContent, 'utf-8');

      const newContent = 'project(NewProject)';

      writeCMakeListsWithMarkers({
        cmakeListsPath: testFilePath,
        generatedContent: newContent,
        configPath: 'new.yaml'
      });

      const content = fs.readFileSync(testFilePath, 'utf-8');

      // Manual content preserved
      assert.ok(content.includes('set(VAR "value")'));

      // Malformed section removed
      assert.ok(!content.includes('OldProject'));

      // New section added
      assert.ok(content.includes('NewProject'));
    });

    test('Proper spacing between manual and generated sections', () => {
      const manualContent = '# Manual\nset(VAR "value")';
      fs.writeFileSync(testFilePath, manualContent, 'utf-8');

      const generatedContent = 'project(MyProject)';

      writeCMakeListsWithMarkers({
        cmakeListsPath: testFilePath,
        generatedContent,
        configPath: 'config.yaml'
      });

      const content = fs.readFileSync(testFilePath, 'utf-8');

      // Should have proper spacing (blank line) between sections
      const lines = content.split('\n');
      let foundBlankLine = false;
      let foundBeginMarker = false;

      for (let i = 0; i < lines.length - 1; i++) {
        if (lines[i] === '' && lines[i + 1].includes('# ======')) {
          foundBlankLine = true;
        }
        if (lines[i].includes('# BEGIN: Generated by CMakeMakers')) {
          foundBeginMarker = true;
        }
      }

      assert.ok(foundBlankLine || !manualContent, 'Should have blank line before generated section');
      assert.ok(foundBeginMarker);
    });
  });

  suite('hasAutoGeneratedSections', () => {
    test('Return false for non-existent file', () => {
      const result = hasAutoGeneratedSections(testFilePath);
      assert.strictEqual(result, false);
    });

    test('Return false for file without markers', () => {
      fs.writeFileSync(testFilePath, 'project(MyProject)\n', 'utf-8');
      const result = hasAutoGeneratedSections(testFilePath);
      assert.strictEqual(result, false);
    });

    test('Return true for file with auto-generated section', () => {
      const content = `# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION
project(MyProject)
# END: Generated by CMakeMakers
`;
      fs.writeFileSync(testFilePath, content, 'utf-8');
      const result = hasAutoGeneratedSections(testFilePath);
      assert.strictEqual(result, true);
    });
  });

  suite('extractManualContent', () => {
    test('Return null for non-existent file', () => {
      const result = extractManualContent(testFilePath);
      assert.strictEqual(result, null);
    });

    test('Return full content for file without markers', () => {
      const manualContent = '# My manual CMake\nproject(MyProject)\n';
      fs.writeFileSync(testFilePath, manualContent, 'utf-8');

      const result = extractManualContent(testFilePath);
      assert.ok(result?.includes('# My manual CMake'));
      assert.ok(result?.includes('project(MyProject)'));
    });

    test('Extract only manual content when markers present', () => {
      const fullContent = `# Manual section
set(CMAKE_CXX_STANDARD 17)

# ============================================================================
# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION
# ============================================================================

project(GeneratedProject)

# ============================================================================
# END: Generated by CMakeMakers
# ============================================================================
`;

      fs.writeFileSync(testFilePath, fullContent, 'utf-8');

      const result = extractManualContent(testFilePath);

      assert.ok(result?.includes('# Manual section'));
      assert.ok(result?.includes('set(CMAKE_CXX_STANDARD 17)'));
      assert.ok(!result?.includes('GeneratedProject'));
      assert.ok(!result?.includes('# BEGIN: Generated by CMakeMakers'));
    });

    test('Extract manual content with multiple sections', () => {
      const content = `# Manual 1
set(VAR1 "a")

# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION
project(Gen1)
# END: Generated by CMakeMakers

# Manual 2
set(VAR2 "b")

# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION
project(Gen2)
# END: Generated by CMakeMakers
`;

      fs.writeFileSync(testFilePath, content, 'utf-8');

      const result = extractManualContent(testFilePath);

      assert.ok(result?.includes('# Manual 1'));
      assert.ok(result?.includes('set(VAR1 "a")'));
      assert.ok(result?.includes('# Manual 2'));
      assert.ok(result?.includes('set(VAR2 "b")'));
      assert.ok(!result?.includes('Gen1'));
      assert.ok(!result?.includes('Gen2'));
    });
  });
});
