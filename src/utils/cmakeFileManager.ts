import * as fs from 'fs';

/**
 * Markers for the auto-generated section in CMakeLists.txt
 */
const BEGIN_MARKER = '# ============================================================================\n' +
                     '# BEGIN: Generated by CMakeMakers - DO NOT EDIT THIS SECTION\n';
const END_MARKER = '# ============================================================================\n' +
                   '# END: Generated by CMakeMakers\n' +
                   '# ============================================================================\n';

/**
 * Options for writing CMakeLists.txt
 */
export interface CMakeWriteOptions {
  cmakeListsPath: string;
  generatedContent: string;
  configPath: string;
}

/**
 * Write or update CMakeLists.txt with generated content.
 *
 * Strategy:
 * 1. If file doesn't exist, create with generated content only
 * 2. If file exists:
 *    - Remove all previous auto-generated sections (between markers)
 *    - Append new auto-generated section at the end
 *    - Preserve all manually written content
 *
 * @param options Write options
 * @returns true if written successfully
 */
export function writeCMakeListsWithMarkers(options: CMakeWriteOptions): boolean {
  const { cmakeListsPath, generatedContent, configPath } = options;

  let finalContent: string;

  if (fs.existsSync(cmakeListsPath)) {
    // File exists - need to preserve manual content and replace auto-generated section
    const existingContent = fs.readFileSync(cmakeListsPath, 'utf-8');
    const manualContent = removeAutoGeneratedSections(existingContent);

    // Append new auto-generated section
    finalContent = buildFinalContent(manualContent, generatedContent, configPath);
  } else {
    // File doesn't exist - create with generated content only
    finalContent = buildGeneratedSection(generatedContent, configPath);
  }

  fs.writeFileSync(cmakeListsPath, finalContent, 'utf-8');
  return true;
}

/**
 * Remove all auto-generated sections (between BEGIN and END markers) from content.
 * Handles multiple auto-generated sections (legacy/error cases).
 *
 * @param content Original CMakeLists.txt content
 * @returns Content with auto-generated sections removed
 */
function removeAutoGeneratedSections(content: string): string {
  let result = content;

  // Remove all occurrences of auto-generated sections
  // Using a simple approach: find BEGIN marker, find corresponding END marker, remove
  while (true) {
    const beginIndex = result.indexOf('# BEGIN: Generated by CMakeMakers');
    if (beginIndex === -1) {
      break;
    }

    // Find the corresponding END marker
    const endMarkerText = '# END: Generated by CMakeMakers';
    const endIndex = result.indexOf(endMarkerText, beginIndex);

    if (endIndex === -1) {
      // Malformed: BEGIN without END, remove from BEGIN to end of file
      result = result.substring(0, beginIndex);
      break;
    }

    // Find the end of the END marker line (including the separator line after it)
    let removeEnd = endIndex + endMarkerText.length;

    // Skip to end of line
    while (removeEnd < result.length && result[removeEnd] !== '\n') {
      removeEnd++;
    }
    if (removeEnd < result.length) {
      removeEnd++; // Skip the newline
    }

    // Also remove the separator line (===...) if present
    if (result.substring(removeEnd).startsWith('# ======')) {
      const nextNewline = result.indexOf('\n', removeEnd);
      if (nextNewline !== -1) {
        removeEnd = nextNewline + 1;
      }
    }

    // Remove this section
    result = result.substring(0, beginIndex) + result.substring(removeEnd);
  }

  // Trim trailing whitespace but keep at least one newline if content exists
  result = result.trimEnd();
  if (result.length > 0) {
    result += '\n';
  }

  return result;
}

/**
 * Build the complete file content with manual + generated sections.
 *
 * @param manualContent User's manual content
 * @param generatedContent Generated CMake content
 * @param configPath Path to the config file (for reference)
 * @returns Complete file content
 */
function buildFinalContent(
  manualContent: string,
  generatedContent: string,
  configPath: string
): string {
  let result = manualContent;

  // Ensure there's proper spacing before the generated section
  if (result.length > 0 && !result.endsWith('\n\n')) {
    if (result.endsWith('\n')) {
      result += '\n';
    } else {
      result += '\n\n';
    }
  }

  // Append the generated section
  result += buildGeneratedSection(generatedContent, configPath);

  return result;
}

/**
 * Build the auto-generated section with markers.
 *
 * @param generatedContent Generated CMake content
 * @param configPath Path to the config file
 * @returns Marked section
 */
function buildGeneratedSection(generatedContent: string, configPath: string): string {
  const timestamp = new Date().toISOString();

  let section = BEGIN_MARKER;
  section += `# Configuration: ${configPath}\n`;
  section += `# Generated at: ${timestamp}\n`;
  section += '# ============================================================================\n\n';

  section += generatedContent;

  // Ensure content ends with newline
  if (!section.endsWith('\n')) {
    section += '\n';
  }
  section += '\n';

  section += END_MARKER;

  return section;
}

/**
 * Check if a CMakeLists.txt file has any auto-generated sections.
 *
 * @param cmakeListsPath Path to CMakeLists.txt
 * @returns true if file contains auto-generated sections
 */
export function hasAutoGeneratedSections(cmakeListsPath: string): boolean {
  if (!fs.existsSync(cmakeListsPath)) {
    return false;
  }

  const content = fs.readFileSync(cmakeListsPath, 'utf-8');
  return content.includes('# BEGIN: Generated by CMakeMakers');
}

/**
 * Extract only the manually written content from a CMakeLists.txt file.
 *
 * @param cmakeListsPath Path to CMakeLists.txt
 * @returns Manual content only, or null if file doesn't exist
 */
export function extractManualContent(cmakeListsPath: string): string | null {
  if (!fs.existsSync(cmakeListsPath)) {
    return null;
  }

  const content = fs.readFileSync(cmakeListsPath, 'utf-8');
  return removeAutoGeneratedSections(content);
}
